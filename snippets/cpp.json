{
	"Simple Boilerplate": {
	"prefix": "/simple",
	"body": [
		"#include <bits/stdc++.h>\r",		
		"using namespace std;\r",
		"\r",
		"int main(){\r",
		"\t$0",
		"\treturn 0;",
		"}"
	],
	"description": "Simple Boilerplate"
	},
	"Basic snippet without testcase": {
	"prefix": "/cpw",
	"body": [
		"#include <bits/stdc++.h>\r",
		"#define ll long long\r",
		"#define endl \"\\n\"\r",			
		"using namespace std;\r",
		"\r",
		"void solve(){",
		"\t$0",
		"}\r",
		"\r",
		"int main(){\r",
		"\tios_base::sync_with_stdio(false); cin.tie(NULL);\r",
		"\tsolve();\r",
		"}"
	],
	"description": "Basic snippet without testcase"
	},
	"Basic snippet with testcase": {
	"prefix": "/cpt",
	"body": [
		"#include <bits/stdc++.h>\r",
		"#define ll long long\r",
		"#define endl \"\\n\"\r",			
		"using namespace std;\r",
		"\r",
		"void solve(){",
		"\t$0",
		"}\r",
		"\r",
		"int main(){\r",
		"\tios_base::sync_with_stdio(false); cin.tie(NULL);\r",
		"\tint tc=1;\r",
		"\tcin>>tc;\r",
		"\twhile(tc--) solve();\r",
		"}"
	],
	"description": "Basic snippet with testcase"
	},
	"for loop (press tab to go next)": {
		"prefix": "/for",
		"body": [
			"for(int ${1:i}=${2:0};${1:i}<${3:n};${1:i}++){",
			"\t$0",
			"}"
		],
		"description": "for loop (press tab to go next)"
	},
	"Reverse for loop": {
		"prefix": "/forr",
		"body": [
			"for(int ${1:i}=${2:n}-1;${1:i}>=${3:0};${1:i}--){",
			"\t$0",
			"}"
		],
		"description": "Reverse for loop"
	},
	"while(){}": {
		"prefix": "/forr",
		"body": [
			"while($1){",
			"\t$0",
			"}"
		],
		"description": "while(){}"
	},
	"cin>>x (change x);": {
		"prefix": "/cin",
		"body": [
			"cin>>${1:x};\r$0"
		],
		"description": "cin>>x (change x);"
	},
	"Declare and input n": {
		"prefix": "/n",
		"body": [
			"int n; cin>>n;\r$0"
		],
		"description": "Declare and input n"
	},
	"Declare and input 1 variable": {
		"prefix": "/in1",
		"body": [
			"${1:int} ${2:x}; cin>>${2:x};\r$0"
		],
		"description": "Declare and input 1 variable"
	},
	"Declare and input 2 variable": {
		"prefix": "/in2",
		"body": [
			"${1:int} ${2:x},${3:y}; cin>>${2:x}>>${3:y};\r$0"
		],
		"description": "Declare and input 2 variable"
	},
	"Declare and input 3 variable": {
		"prefix": "/in3",
		"body": [
			"${1:int} ${2:x},${3:y},${4:z}; cin>>${2:x}>>${3:y}>>${4:z};\r$0"
		],
		"description": "Declare and input 3 variable"
	},
	"New line": {
		"prefix": "/nl",
		"body": [
			"cout<<endl;$0"
		],
		"description": "New line"
	},
	"cout 1 with space (best for array print)": {
		"prefix": "/outs",
		"body": [
			"cout<<${1:x}<<\" \";$0"
		],
		"description": "cout one with space"
	},
	"cout 1 variable": {
		"prefix": "/out1",
		"body": [
			"cout<<${1:x}<<endl;$0"
		],
		"description": "cout 1 variable"
	},
	"cout 2 variable": {
		"prefix": "/out2",
		"body": [
			"cout<<${1:x}<<\" \"<<${2:y}<<endl;$0"
		],
		"description": "cout 2 variable"
	},
	"n size vector declare and input": {
		"prefix": "/vn",
		"body": [
			"vector<${1:ll}>v(n);",
			"for(int i=0;i<n;i++){",
			"\tcin>>v[i];$2",
			"}$0"
		],
		"description": "n size vector declare and input"
	},
	"vector (change data type and name)": {
		"prefix": "/vector",
		"body": [
			"vector<${1:int}>${2:v};$0"
		],
		"description": "Vector"
	},
	"pair": {
		"prefix": "/pair",
		"body": [
			"pair<${1:int},${2:int}>;$0"
		],
		"description": "Pair"
	},
	"map (change data type and name)": {
		"prefix": "/map",
		"body": [
			"map<${1:int},${2:int}>${3:mp};$0"
		],
		"description": "Map"
	},
	"set (change data type and name)": {
		"prefix": "/set",
		"body": [
			"set<${1:int}>${2:st};$0"
		],
		"description": "set"
	},
	"if(){}": {
		"prefix": "/if",
		"body": [
			"if($1){",
			"\t$0",
			"}"
		],
		"description": "if(){}"
	},
	"else if(){}": {
		"prefix": "/elif",
		"body": [
			"else if($1){",
			"\t$0",
			"}"
		],
		"description": "else if(){}"
	},
	"else{}": {
		"prefix": "/else",
		"body": [
			"else{",
			"\t$0",
			"}"
		],
		"description": "else{}"
	},
	"singly linked list node": {
		"prefix": "/singly",
		"body": [
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *next;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->next=NULL;\r",
			"   }\r",
			"};"
		],
		"description": "singly linked list node"
	},
	"doubly linked list node": {
		"prefix": "/doubly",
		"body": [
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *next;\r",
			"      Node *prev;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->next=NULL;\r",
			"      this->prev=NULL;\r",
			"   }\r",
			"};"
		],
		"description": "doubly linked list node"
	},
	"tree node": {
		"prefix": "/tree",
		"body": [
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *right;\r",
			"      Node *left;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->right=NULL;\r",
			"      this->left=NULL;\r",
			"   }\r",
			"};"
		],
		"description": "tree node"
	},
	"begin()": {
		"prefix": ".be",
		"body": [
			".begin()$0"
		],
		"description": "begin()"
	},
	"end()": {
		"prefix": ".end",
		"body": [
			".end()$0"
		],
		"description": "end()"
	},
	"v.begin(),v.end()": {
		"prefix": "/all",
		"body": [
			"${1:v}.begin(),${1:v}.end()$0"
		],
		"description": "v.begin(),v.end() [change v]"
	},
	"push_back(x);": {
		"prefix": ".pb",
		"body": [
			".push_back(${1:x});$0"
		],
		"description": "push_back(x);"
	},
	"pop_back();": {
		"prefix": ".pop",
		"body": [
			".pop_back();$0"
		],
		"description": "pop_back();"
	},
	".size()": {
		"prefix": ".sz",
		"body": [
			".size()$0"
		],
		"description": "size()"
	},
	"first": {
		"prefix": ".fi",
		"body": [
			".first$0"
		],
		"description": "first"
	},
	"second": {
		"prefix": ".se",
		"body": [
			".second$0"
		],
		"description": "second"
	},
	"insert(x);": {
		"prefix": ".in",
		"body": [
			".insert(${1:x});$0"
		],
		"description": "insert(x);"
	},
	"sort vector": {
		"prefix": "/sort",
		"body": [
			"sort(${1:v}.begin(),${1:v}.end());$0"
		],
		"description": "sort vector"
	},
	"sort vector (descending)": {
		"prefix": "/sorttt",
		"body": [
			"sort(${1:v}.begin(),${1:v}.end(),greater<int>());$0"
		],
		"description": "sort vector (descending)"
	},
	"class name(){}": {
		"prefix": "/class",
		"body": [
			"class ${1:name}{\r",
			"\t$0\r",
			"};"
		],
		"description": "Snippet for class"
	},
	"swap two number": {
		"prefix": "/swap",
		"body": "swap(${1:x},${2:y});$0",
		"description": "swap(x,y);"
	},
	"max of two number": {
		"prefix": "/mx",
		"body": "max(${1:x},${2:y});$0",
		"description": "max(x,y);"
	},
	"min of two number": {
		"prefix": "/mn",
		"body": "min(${1:x},${2:y});$0",
		"description": "min(x,y);"
	},
	"while(){}_58b1a52c-0d2b-4484-884e-99793a50134b": {
		"prefix": "/while",
		"body": [
			"while($1){\r",
			"\t$0\r",
			"}"
		],
		"description": "while(){}"
	},
	"memset": {
		"prefix": "/memset",
		"body": "memset(${1:v},${2:-1},sizeof(${1:v}));$0",
		"description": "memset"
	},
	"/bfs": {
		"prefix": "/bfs_traversal",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"const int N=1e5+10; \r",
			"vector<int>graph[N];\r",
			"bool vis[N];\r",
			"\r",
			"void bfs(int src){\r",
			"    queue<int>q;\r",
			"    q.push(src);\r",
			"    vis[src]=true;\r",
			"    while(q.size()){\r",
			"        int par=q.front();\r",
			"        q.pop();\r",
			"        cout<<par<<endl;\r",
			"        for(auto child:graph[par]){\r",
			"            if(!vis[child]){\r",
			"                q.push(child);\r",
			"                vis[child]=true;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y; cin>>x>>y;\r",
			"        graph[x].push_back(y);;\r",
			"        graph[y].push_back(x);;\r",
			"    }\r",
			"    int src; cin>>src;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    bfs(src);\r",
			"}\r",
			"// 7 8\r",
			"// 0 1 \r",
			"// 1 2 \r",
			"// 0 4 \r",
			"// 1 3 \r",
			"// 2 0\r",
			"// 3 4\r",
			"// 1 5\r",
			"// 3 6"
		],
		"description": "/bfs_traversal"
	},
	"/bfs_level": {
		"prefix": "/bfs_level",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"const int N=1e5+10;\r",
			"vector<int>graph[N];\r",
			"bool vis[N];\r",
			"int level[N];\r",
			"\r",
			"void bfs(int src){\r",
			"    queue<int>q;\r",
			"    q.push(src);\r",
			"    vis[src]=true;\r",
			"    level[src]=0;\r",
			"    while(q.size()){\r",
			"        int par=q.front();\r",
			"        q.pop();\r",
			"        for(auto child:graph[par]){\r",
			"            if(!vis[child]){\r",
			"                q.push(child);\r",
			"                vis[child]=true;\r",
			"                level[child]=level[par]+1;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y; cin>>x>>y;\r",
			"        graph[x].push_back(y);;\r",
			"        graph[y].push_back(x);;\r",
			"    }\r",
			"    int src; cin>>src;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    bfs(src);\r",
			"    for(int i=0;i<n;i++){\r",
			"        cout<<i<<\" \"<<level[i]<<endl;\r",
			"    }\r",
			"}\r",
			"// 7 8\r",
			"// 0 1 \r",
			"// 1 2 \r",
			"// 0 4 \r",
			"// 1 3 \r",
			"// 2 0\r",
			"// 3 4\r",
			"// 1 5\r",
			"// 3 6"
		],
		"description": "/bfs_level"
	},
	"/path": {
		"prefix": "/path",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"const int N=1e5+10;\r",
			"vector<int>graph[N];\r",
			"bool vis[N];\r",
			"int level[N];\r",
			"int parent[N];\r",
			"\r",
			"void bfs(int src,int dest){\r",
			"    queue<int>q;\r",
			"    q.push(src);\r",
			"    vis[src]=true;\r",
			"    level[src]=0;\r",
			"    parent[src]=0;\r",
			"    while(q.size()){\r",
			"        int par=q.front();\r",
			"        q.pop();\r",
			"        for(auto child:graph[par]){\r",
			"            if(!vis[child]){\r",
			"                q.push(child);\r",
			"                vis[child]=true;\r",
			"                level[child]=level[par]+1;\r",
			"                parent[child]=par;\r",
			"            }\r",
			"            if(child==dest){\r",
			"                return;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y; cin>>x>>y;\r",
			"        graph[x].push_back(y);;\r",
			"        graph[y].push_back(x);;\r",
			"    }\r",
			"    int src,dest; cin>>src>>dest;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    memset(level,-1,sizeof(level));\r",
			"    memset(parent,-1,sizeof(parent));\r",
			"    bfs(src,dest);\r",
			"    int cur=dest;\r",
			"    vector<int>path;\r",
			"    while(69){\r",
			"        if(cur==src){\r",
			"            path.push_back(cur);\r",
			"            break;\r",
			"        }\r",
			"        path.push_back(cur);\r",
			"        cur=parent[cur];\r",
			"    }\r",
			"    reverse(path.begin(),path.end());\r",
			"    for(auto x:path) cout<<x<<\" \";\r",
			"}\r",
			"// 7 8\r",
			"// 0 1 \r",
			"// 1 2 \r",
			"// 0 4 \r",
			"// 1 3 \r",
			"// 2 0\r",
			"// 3 4\r",
			"// 1 5\r",
			"// 3 6"
		],
		"description": "/path"
	},
	"/dfs_2d": {
		"prefix": "/dfs_2d",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define endl '\\n'\r",
			"using namespace std;\r",
			"char a[20][20];\r",
			"bool vis[20][20];\r",
			"vector<pair<int,int>>d={{0,1},{0,-1},{-1,0},{1,0}};\r",
			"int n,m;\r",
			"bool valid(int x,int y){\r",
			"    return (x>=0 and x<n and y>=0 and y<m);\r",
			"}\r",
			"\r",
			"void dfs(int x,int y){\r",
			"    cout<<x<<\" \"<<y<<endl;\r",
			"    vis[x][y]=true;\r",
			"    for(int i=0;i<4;i++){\r",
			"        int ci=x+d[i].first;\r",
			"        int cj=y+d[i].second;\r",
			"        if(valid(ci,cj) and !vis[ci][cj]){\r",
			"            dfs(ci,cj);\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"    cin>>n>>m;\r",
			"    for(int i=0;i<n;i++){\r",
			"        for(int j=0;j<m;j++){\r",
			"            cin>>a[i][j];\r",
			"        }\r",
			"    }\r",
			"    int x,y; cin>>x>>y;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    memset(a,0,sizeof(a));\r",
			"    dfs(x,y);\r",
			"}"
		],
		"description": "/dfs_2d"
	},
	"/dfs": {
		"prefix": "/dfs",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define endl '\\n'\r",
			"using namespace std;\r",
			"const int N=1e5+10; \r",
			"vector<int>graph[N];\r",
			"bool vis[N];\r",
			"\r",
			"void dfs(int src){\r",
			"    cout<<src<<endl;\r",
			"    vis[src]=true;\r",
			"    for(auto child:graph[src]){\r",
			"        if(!vis[child]) dfs(child);\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y; cin>>x>>y;\r",
			"        graph[x].push_back(y);;\r",
			"        graph[y].push_back(x);;\r",
			"    }\r",
			"    int src; cin>>src;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    dfs(src);\r",
			"}"
		],
		"description": "/dfs"
	},
	"/bfs_2d": {
		"prefix": "/bfs_2d",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define endl '\\n'\r",
			"using namespace std;\r",
			"char a[20][20];\r",
			"bool vis[20][20];\r",
			"int dis[20][20];\r",
			"vector<pair<int,int>>d={{0,1},{0,-1},{-1,0},{1,0}};\r",
			"int n,m;\r",
			"bool valid(int x,int y){\r",
			"    return (x>=0 and x<n and y>=0 and y<m);\r",
			"}\r",
			"\r",
			"void bfs(int x,int y){\r",
			"    queue<pair<int,int>>q;\r",
			"    q.push({x,y});\r",
			"    vis[x][y]=true;\r",
			"    dis[x][y]=0;\r",
			"    while(q.size()){\r",
			"        pair<int,int> par=q.front();\r",
			"        int a=par.first, b=par.second;\r",
			"        // cout<<a<<\" \"<<b<<endl;\r",
			"        q.pop();\r",
			"        for(int i=0;i<4;i++){\r",
			"            int ci=a+d[i].first;\r",
			"            int cj=b+d[i].second;\r",
			"            if(valid(ci,cj) and !vis[ci][cj]){\r",
			"                q.push({ci,cj});\r",
			"                vis[ci][cj]=true;\r",
			"                dis[ci][cj]=dis[a][b]+1;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"    cin>>n>>m;\r",
			"    for(int i=0;i<n;i++){\r",
			"        for(int j=0;j<m;j++){\r",
			"            cin>>a[i][j];\r",
			"        }\r",
			"    }\r",
			"    int x,y; cin>>x>>y;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    memset(dis,-1,sizeof(dis));\r",
			"    memset(a,0,sizeof(a));\r",
			"    bfs(x,y);\r",
			"    cout<<dis[0][3];\r",
			"}\r",
			"/*\r",
			"3 4 \r",
			"....\r",
			"....\r",
			"....\r",
			"0 0\r",
			"*/"
		],
		"description": "/bfs_2d"
	},
	"/dijkstra": {
		"prefix": "/dijkstra",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"const int N=1e5+10; \r",
			"vector<pair<int,int>>graph[N];\r",
			"int dis[N];\r",
			"\r",
			"class cmp{\r",
			"    public:\r",
			"    bool operator()(auto a,auto b){\r",
			"        return a.second>b.second;\r",
			"    }\r",
			"};\r",
			"\r",
			"void dijkstra(int src){\r",
			"    priority_queue<pair<int,int>,vector<pair<int,int>>,cmp>q;\r",
			"    q.push({src,0});\r",
			"    dis[src]=0;\r",
			"    while(q.size()){\r",
			"        auto par=q.top();\r",
			"        q.pop();\r",
			"        int node=par.first;\r",
			"        int cost=par.second;\r",
			"        for(auto child:graph[node]){\r",
			"            int childNode=child.first;\r",
			"            int childCost=child.second;\r",
			"            if(cost+childCost<dis[childNode]){\r",
			"                dis[childNode]=cost+childCost;\r",
			"                q.push({childNode,cost+childCost});\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y,z; cin>>x>>y>>z;\r",
			"        graph[x].push_back({y,z});;\r",
			"        graph[y].push_back({x,z});;\r",
			"    }\r",
			"    // int src; cin>>src;\r",
			"    // memset(dis,INT_MAX,sizeof(dis));\r",
			"    for(int i=0;i<n;i++) dis[i]=INT_MAX;\r",
			"    dijkstra(0);\r",
			"    for(int i=0;i<n;i++) cout<<dis[i]<<\" \";\r",
			"}\r",
			"// 5 8\r",
			"// 0 1 10 \r",
			"// 0 2 7\r",
			"// 0 3 4\r",
			"// 1 4 3\r",
			"// 2 4 5\r",
			"// 2 1 1\r",
			"// 3 4 5\r",
			"// 3 2 1"
		],
		"description": "/dijkstra"
	},
	"/bst_search": {
		"prefix": "/bst_search",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define ll long long\r",
			"#define endl \"\\n\"\r",
			"using namespace std;\r",
			"\r",
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *right;\r",
			"      Node *left;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->right=NULL;\r",
			"      this->left=NULL;\r",
			"   }\r",
			"};\r",
			"\r",
			"Node* input(){\r",
			"   int val; cin>>val;\r",
			"   Node* root; \r",
			"   if(val==-1) root=NULL;\r",
			"   else root=new Node(val);\r",
			"\r",
			"   queue<Node*>q;\r",
			"   if(root) q.push(root);\r",
			"   while(q.size()){\r",
			"      Node* p=q.front();\r",
			"      q.pop();\r",
			"      int l ,r ; cin>>l >>r;\r",
			"      Node *lft, *rht;\r",
			"      if(l==-1) lft=NULL;\r",
			"      else lft=new Node(l);\r",
			"\r",
			"      if(r==-1) rht=NULL;\r",
			"      else rht=new Node(r);\r",
			"\r",
			"      p->left=lft;\r",
			"      p->right=rht;\r",
			"\r",
			"      if(p->left) q.push(p->left);\r",
			"      if(p->right) q.push(p->right);\r",
			"   }\r",
			"   return root;\r",
			"}\r",
			"\r",
			"bool search(Node *root, int x){\r",
			"    if(root==NULL) return false;\r",
			"    if(root->val==x) return true;\r",
			"    if(x<root->val){\r",
			"        return search(root->left,x);\r",
			"    }\r",
			"    else{\r",
			"        return search(root->right,x);\r",
			"    }\r",
			"}\r",
			"\r",
			"void solve(){\r",
			"    Node* root=input();\r",
			"    if(search(root,6)) cout<<\"Found\"<<endl;\r",
			"    else cout<<\"Not Found\"<<endl;\r",
			"}\r",
			"\r",
			"int main(){\r",
			"   ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"   solve();\r",
			"}\r",
			"\r",
			"// 10 5 15 2 6 12 16 -1 3 -1 -1 -1 -1 -1 -1 -1 -1"
		],
		"description": "/bst_search"
	},
	"/bst_insert": {
		"prefix": "/bst_insert",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define ll long long\r",
			"#define endl \"\\n\"\r",
			"using namespace std;\r",
			"\r",
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *right;\r",
			"      Node *left;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->right=NULL;\r",
			"      this->left=NULL;\r",
			"   }\r",
			"};\r",
			"\r",
			"Node* input(){\r",
			"   int val; cin>>val;\r",
			"   Node* root; \r",
			"   if(val==-1) root=NULL;\r",
			"   else root=new Node(val);\r",
			"\r",
			"   queue<Node*>q;\r",
			"   if(root) q.push(root);\r",
			"   while(q.size()){\r",
			"      Node* p=q.front();\r",
			"      q.pop();\r",
			"      int l ,r ; cin>>l >>r;\r",
			"      Node *lft, *rht;\r",
			"      if(l==-1) lft=NULL;\r",
			"      else lft=new Node(l);\r",
			"\r",
			"      if(r==-1) rht=NULL;\r",
			"      else rht=new Node(r);\r",
			"\r",
			"      p->left=lft;\r",
			"      p->right=rht;\r",
			"\r",
			"      if(p->left) q.push(p->left);\r",
			"      if(p->right) q.push(p->right);\r",
			"   }\r",
			"   return root;\r",
			"}\r",
			"\r",
			"void insert(Node* root,int x){\r",
			"    if(root==NULL) root=new Node(x);\r",
			"    if(x<root->val){\r",
			"        if(root->left) insert(root->left,x);\r",
			"        else root->left=new Node(x);\r",
			"    }\r",
			"    else{\r",
			"        if(root->right) insert(root->right,x);\r",
			"        else root->right=new Node(x);\r",
			"    }\r",
			"}\r",
			"\r",
			"void level(Node* root){\r",
			"   if(root==NULL) return;\r",
			"    queue<Node*>q;\r",
			"    q.push(root);\r",
			"    while(q.size()){\r",
			"        // 1. Ber kore ana\r",
			"        Node* f=q.front();\r",
			"        q.pop();\r",
			"        // 2. Jabotiyo Kaj\r",
			"        cout<<f->val<<\" \";\r",
			"        // 3. tar Children der line e rakha\r",
			"        if(f->left) q.push(f->left);\r",
			"        if(f->right) q.push(f->right);\r",
			"    }\r",
			"}\r",
			"\r",
			"void inorder(Node* root){\r",
			"    if(root==NULL){\r",
			"        return;\r",
			"    }\r",
			"    inorder(root->left);\r",
			"    cout<<root->val<<\" \";\r",
			"    inorder(root->right);\r",
			"}\r",
			"\r",
			"void solve(){\r",
			"    Node* root=input();\r",
			"    int x; cin>>x;\r",
			"    insert(root, x);\r",
			"    level(root);\r",
			"    // inorder(root);\r",
			"}\r",
			"\r",
			"int main(){\r",
			"   ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"   solve();\r",
			"}\r",
			"\r",
			"// 20\r",
			"// 10 30\r",
			"// 5 15 21 35 \r",
			"// -1 -1 -1 19 -1 -1 -1 -1 \r",
			"// -1 -1 \r",
			"// 16"
		],
		"description": "/bst_insert"
	},
	"/heap_min": {
		"prefix": "/heap_min",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"\r",
			"int main(){\r",
			"    int n; cin>>n;\r",
			"    vector<int>v;\r",
			"    for(int i=0;i<n;i++){\r",
			"        int x; cin>>x;\r",
			"        v.push_back(x);\r",
			"        int cur=v.size()-1;\r",
			"        while(cur){\r",
			"            int par=(cur-1)/2;\r",
			"            if(v[par]>v[cur]) swap(v[cur],v[par]);\r",
			"            cur=par;\r",
			"        }        \r",
			"    }\r",
			"    for(auto x:v) cout<<x<<\" \";\r",
			"}"
		],
		"description": "/heap_min"
	},
	"/heap_delete": {
		"prefix": "/heap_delete",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"\r",
			"void insert(vector<int>&v, int x){\r",
			"    v.push_back(x);\r",
			"    int cur=v.size()-1;\r",
			"    while(cur){\r",
			"        int par=(cur-1)/2;\r",
			"        if(v[par]<v[cur]) swap(v[cur],v[par]);\r",
			"        else break;\r",
			"        cur=par;\r",
			"    }        \r",
			"}\r",
			"\r",
			"void delete_(vector<int>&v){\r",
			"    v[0]=v[v.size()-1];\r",
			"    v.pop_back();\r",
			"    int cur=0;\r",
			"    while(69){\r",
			"        int l=cur*2+1;\r",
			"        int r=cur*2+2;\r",
			"        if(l<v.size() and r<v.size()){\r",
			"            if(v[l]>=v[r] and v[l]>v[cur]){\r",
			"                swap(v[l],v[cur]);\r",
			"                cur=l;\r",
			"            }\r",
			"            else if(v[r]>=v[l] and v[r]>v[cur]){\r",
			"                swap(v[r],v[cur]);\r",
			"                cur=r;\r",
			"            }\r",
			"            else break;\r",
			"        }\r",
			"        else if(l<v.size()){\r",
			"            if(v[l]>v[cur]){\r",
			"                swap(v[l],v[cur]);\r",
			"                cur=l;\r",
			"            }\r",
			"            else break;\r",
			"        }\r",
			"        else if(r<v.size()){\r",
			"            if(v[r]>v[cur]){\r",
			"                swap(v[r],v[cur]);\r",
			"                cur=r;\r",
			"            }\r",
			"            else break;\r",
			"        }\r",
			"        else break;\r",
			"    }\r",
			"}\r",
			"\r",
			"void print(vector<int>&v){\r",
			"    for(auto x:v) cout<<x<<\" \";\r",
			"    cout<<endl;\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n; cin>>n;\r",
			"    vector<int>v;\r",
			"    for(int i=0;i<n;i++){\r",
			"        int x; cin>>x;\r",
			"        insert(v,x);\r",
			"    }\r",
			"    print(v);\r",
			"    delete_(v);\r",
			"    print(v);\r",
			"    delete_(v);\r",
			"    print(v);\r",
			"    delete_(v);\r",
			"    print(v);\r",
			"}"
		],
		"description": "/heap_delete"
	},
	"/queue": {
		"prefix": "/queue",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"\r",
			"class node{\r",
			"   public:\r",
			"      int val;\r",
			"      node *next;\r",
			"   node(int val){\r",
			"      this->val=val;\r",
			"      this->next=NULL;\r",
			"   }\r",
			"};\r",
			"\r",
			"\r",
			"class Queue{\r",
			"   public:\r",
			"   node *head=NULL;\r",
			"   node *tail=NULL;\r",
			"   int sz=0;\r",
			"   void push(int val){\r",
			"      sz++;\r",
			"      node *newNode=new node(val);\r",
			"      if(head==NULL){\r",
			"         head=newNode;\r",
			"         tail=newNode;\r",
			"         return;\r",
			"      }\r",
			"      tail->next=newNode;\r",
			"      tail=tail->next;\r",
			"   }\r",
			"   void pop(){\r",
			"      sz--;\r",
			"      node *deleteNode=head;\r",
			"      head=head->next;\r",
			"      delete deleteNode;\r",
			"      if(head==NULL){\r",
			"         tail=NULL; \r",
			"      }\r",
			"   }\r",
			"   int front(){\r",
			"      return head->val;\r",
			"   }\r",
			"   int size(){\r",
			"      return sz;\r",
			"   }\r",
			"   bool empty(){\r",
			"      if(sz) return false;\r",
			"      else return true;\r",
			"   }\r",
			"};\r",
			"\r",
			"int main(){\r",
			"   Queue st;\r",
			"   int n; cin>>n;\r",
			"   for(int i=0;i<n;i++){\r",
			"      int x; cin>>x;\r",
			"      st.push(x);\r",
			"   }\r",
			"   while(!st.empty()){\r",
			"      cout<<st.front()<<endl;\r",
			"      st.pop();\r",
			"   }\r",
			"}"
		],
		"description": "/queue"
	},
	"/stack": {
		"prefix": "/stack",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"\r",
			"class Stack{\r",
			"   public:\r",
			"   vector<int>v;\r",
			"   void push(int val){\r",
			"      v.push_back(val);\r",
			"   }\r",
			"   void pop(){\r",
			"      v.pop_back();\r",
			"   }\r",
			"   int top(){\r",
			"      return v.back();\r",
			"   }\r",
			"   int size(){\r",
			"      return v.size();\r",
			"   }\r",
			"   bool empty(){\r",
			"      if(v.size()) return false;\r",
			"      else return true;\r",
			"   }\r",
			"};\r",
			"\r",
			"int main(){\r",
			"   Stack st;\r",
			"   int n; cin>>n;\r",
			"   for(int i=0;i<n;i++){\r",
			"      int x; cin>>x;\r",
			"      st.push(x);\r",
			"   }\r",
			"   while(!st.empty()){\r",
			"      cout<<st.top()<<endl;\r",
			"      st.pop();\r",
			"   }\r",
			"}"
		],
		"description": "/stack"
	}
}
