{
	"Simple Boilerplate": {
	"prefix": "/simple",
	"body": [
		"#include <bits/stdc++.h>\r",		
		"using namespace std;\r",
		"\r",
		"int main(){\r",
		"\t$0",
		"\treturn 0;",
		"}"
	],
	"description": "Simple Boilerplate"
	},
	"Basic snippet without testcase": {
	"prefix": "/cpw",
	"body": [
		"#include <bits/stdc++.h>\r",
		"#define ll long long\r",
		"#define endl \"\\n\"\r",			
		"using namespace std;\r",
		"\r",
		"void solve(){",
		"\t$0",
		"}\r",
		"\r",
		"int main(){\r",
		"\tios_base::sync_with_stdio(false); cin.tie(NULL);\r",
		"\tsolve();\r",
		"}"
	],
	"description": "Basic snippet without testcase"
	},
	"Basic snippet with testcase": {
	"prefix": "/cpt",
	"body": [
		"#include <bits/stdc++.h>\r",
		"#define ll long long\r",
		"#define endl \"\\n\"\r",			
		"using namespace std;\r",
		"\r",
		"void solve(){",
		"\t$0",
		"}\r",
		"\r",
		"int main(){\r",
		"\tios_base::sync_with_stdio(false); cin.tie(NULL);\r",
		"\tint tc=1;\r",
		"\tcin>>tc;\r",
		"\twhile(tc--) solve();\r",
		"}"
	],
	"description": "Basic snippet with testcase"
	},
	"for loop (press tab to go next)": {
		"prefix": "/for",
		"body": [
			"for(int ${1:i}=${2:0};${1:i}<${3:n};${1:i}++){",
			"\t$0",
			"}"
		],
		"description": "for loop (press tab to go next)"
	},
	"Reverse for loop": {
		"prefix": "/forr",
		"body": [
			"for(int ${1:i}=${2:n}-1;${1:i}>=${3:0};${1:i}--){",
			"\t$0",
			"}"
		],
		"description": "Reverse for loop"
	},
	"while(){}": {
		"prefix": "/forr",
		"body": [
			"while($1){",
			"\t$0",
			"}"
		],
		"description": "while(){}"
	},
	"cin>>x (change x);": {
		"prefix": "/cin",
		"body": [
			"cin>>${1:x};\r$0"
		],
		"description": "cin>>x (change x);"
	},
	"Declare and input n": {
		"prefix": "/n",
		"body": [
			"int n; cin>>n;\r$0"
		],
		"description": "Declare and input n"
	},
	"Declare and input 1 variable": {
		"prefix": "/in1",
		"body": [
			"${1:int} ${2:x}; cin>>${2:x};\r$0"
		],
		"description": "Declare and input 1 variable"
	},
	"Declare and input 2 variable": {
		"prefix": "/in2",
		"body": [
			"${1:int} ${2:x},${3:y}; cin>>${2:x}>>${3:y};\r$0"
		],
		"description": "Declare and input 2 variable"
	},
	"Declare and input 3 variable": {
		"prefix": "/in3",
		"body": [
			"${1:int} ${2:x},${3:y},${4:z}; cin>>${2:x}>>${3:y}>>${4:z};\r$0"
		],
		"description": "Declare and input 3 variable"
	},
	"New line": {
		"prefix": "/nl",
		"body": [
			"cout<<endl;$0"
		],
		"description": "New line"
	},
	"cout 1 with space (best for array print)": {
		"prefix": "/outs",
		"body": [
			"cout<<${1:x}<<\" \";$0"
		],
		"description": "cout one with space"
	},
	"cout 1 variable": {
		"prefix": "/out1",
		"body": [
			"cout<<${1:x}<<endl;$0"
		],
		"description": "cout 1 variable"
	},
	"cout 2 variable": {
		"prefix": "/out2",
		"body": [
			"cout<<${1:x}<<\" \"<<${2:y}<<endl;$0"
		],
		"description": "cout 2 variable"
	},
	"n size vector declare and input": {
		"prefix": "/vn",
		"body": [
			"vector<${1:ll}>v(n);",
			"for(int i=0;i<n;i++){",
			"\tcin>>v[i];$2",
			"}$0"
		],
		"description": "n size vector declare and input"
	},
	"vector (change data type and name)": {
		"prefix": "/vector",
		"body": [
			"vector<${1:int}>${2:v};$0"
		],
		"description": "Vector"
	},
	"pair": {
		"prefix": "/pair",
		"body": [
			"pair<${1:int},${2:int}>;$0"
		],
		"description": "Pair"
	},
	"map (change data type and name)": {
		"prefix": "/map",
		"body": [
			"map<${1:int},${2:int}>${3:mp};$0"
		],
		"description": "Map"
	},
	"set (change data type and name)": {
		"prefix": "/set",
		"body": [
			"set<${1:int}>${2:st};$0"
		],
		"description": "set"
	},
	"if(){}": {
		"prefix": "/if",
		"body": [
			"if($1){",
			"\t$0",
			"}"
		],
		"description": "if(){}"
	},
	"else if(){}": {
		"prefix": "/elif",
		"body": [
			"else if($1){",
			"\t$0",
			"}"
		],
		"description": "else if(){}"
	},
	"else{}": {
		"prefix": "/else",
		"body": [
			"else{",
			"\t$0",
			"}"
		],
		"description": "else{}"
	},
	"singly linked list node": {
		"prefix": "/singly",
		"body": [
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *next;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->next=NULL;\r",
			"   }\r",
			"};"
		],
		"description": "singly linked list node"
	},
	"doubly linked list node": {
		"prefix": "/doubly",
		"body": [
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *next;\r",
			"      Node *prev;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->next=NULL;\r",
			"      this->prev=NULL;\r",
			"   }\r",
			"};"
		],
		"description": "doubly linked list node"
	},
	"tree node": {
		"prefix": "/tree",
		"body": [
			"class Node{\r",
			"   public:\r",
			"      int val;\r",
			"      Node *right;\r",
			"      Node *left;\r",
			"   Node(int val){\r",
			"      this->val=val;\r",
			"      this->right=NULL;\r",
			"      this->left=NULL;\r",
			"   }\r",
			"};"
		],
		"description": "tree node"
	},
	"begin()": {
		"prefix": ".be",
		"body": [
			".begin()$0"
		],
		"description": "begin()"
	},
	"end()": {
		"prefix": ".end",
		"body": [
			".end()$0"
		],
		"description": "end()"
	},
	"v.begin(),v.end()": {
		"prefix": "/all",
		"body": [
			"${1:v}.begin(),${1:v}.end()$0"
		],
		"description": "v.begin(),v.end() [change v]"
	},
	"push_back(x);": {
		"prefix": ".pb",
		"body": [
			".push_back(${1:x});$0"
		],
		"description": "push_back(x);"
	},
	"pop_back();": {
		"prefix": ".pop",
		"body": [
			".pop_back();$0"
		],
		"description": "pop_back();"
	},
	".size()": {
		"prefix": ".sz",
		"body": [
			".size()$0"
		],
		"description": "size()"
	},
	"first": {
		"prefix": ".fi",
		"body": [
			".first$0"
		],
		"description": "first"
	},
	"second": {
		"prefix": ".se",
		"body": [
			".second$0"
		],
		"description": "second"
	},
	"insert(x);": {
		"prefix": ".in",
		"body": [
			".insert(${1:x});$0"
		],
		"description": "insert(x);"
	},
	"sort vector": {
		"prefix": "/sort",
		"body": [
			"sort(${1:v}.begin(),${1:v}.end());$0"
		],
		"description": "sort vector"
	},
	"sort vector (descending)": {
		"prefix": "/sorttt",
		"body": [
			"sort(${1:v}.begin(),${1:v}.end(),greater<int>());$0"
		],
		"description": "sort vector (descending)"
	},
	"class name(){}": {
		"prefix": "/class",
		"body": [
			"class ${1:name}{\r",
			"\t$0\r",
			"};"
		],
		"description": "Snippet for class"
	},
	"swap two number": {
		"prefix": "/swap",
		"body": "swap(${1:x},${2:y});$0",
		"description": "swap(x,y);"
	},
	"max of two number": {
		"prefix": "/mx",
		"body": "max(${1:x},${2:y});$0",
		"description": "max(x,y);"
	},
	"min of two number": {
		"prefix": "/mn",
		"body": "min(${1:x},${2:y});$0",
		"description": "min(x,y);"
	},
	"while(){}_58b1a52c-0d2b-4484-884e-99793a50134b": {
		"prefix": "/while",
		"body": [
			"while($1){\r",
			"\t$0\r",
			"}"
		],
		"description": "while(){}"
	},
	"memset": {
		"prefix": "/memset",
		"body": "memset(${1:v},${2:-1},sizeof(${1:v}));$0",
		"description": "memset"
	},
	"/bfs": {
		"prefix": "/bfs_traversal",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"const int N=1e5+10; \r",
			"vector<int>graph[N];\r",
			"bool vis[N];\r",
			"\r",
			"void bfs(int src){\r",
			"    queue<int>q;\r",
			"    q.push(src);\r",
			"    vis[src]=true;\r",
			"    while(q.size()){\r",
			"        int par=q.front();\r",
			"        q.pop();\r",
			"        cout<<par<<endl;\r",
			"        for(auto child:graph[par]){\r",
			"            if(!vis[child]){\r",
			"                q.push(child);\r",
			"                vis[child]=true;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y; cin>>x>>y;\r",
			"        graph[x].push_back(y);;\r",
			"        graph[y].push_back(x);;\r",
			"    }\r",
			"    int src; cin>>src;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    bfs(src);\r",
			"}\r",
			"// 7 8\r",
			"// 0 1 \r",
			"// 1 2 \r",
			"// 0 4 \r",
			"// 1 3 \r",
			"// 2 0\r",
			"// 3 4\r",
			"// 1 5\r",
			"// 3 6"
		],
		"description": "/bfs_traversal"
	},
	"/bfs_level": {
		"prefix": "/bfs_level",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"const int N=1e5+10;\r",
			"vector<int>graph[N];\r",
			"bool vis[N];\r",
			"int level[N];\r",
			"\r",
			"void bfs(int src){\r",
			"    queue<int>q;\r",
			"    q.push(src);\r",
			"    vis[src]=true;\r",
			"    level[src]=0;\r",
			"    while(q.size()){\r",
			"        int par=q.front();\r",
			"        q.pop();\r",
			"        for(auto child:graph[par]){\r",
			"            if(!vis[child]){\r",
			"                q.push(child);\r",
			"                vis[child]=true;\r",
			"                level[child]=level[par]+1;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y; cin>>x>>y;\r",
			"        graph[x].push_back(y);;\r",
			"        graph[y].push_back(x);;\r",
			"    }\r",
			"    int src; cin>>src;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    bfs(src);\r",
			"    for(int i=0;i<n;i++){\r",
			"        cout<<i<<\" \"<<level[i]<<endl;\r",
			"    }\r",
			"}\r",
			"// 7 8\r",
			"// 0 1 \r",
			"// 1 2 \r",
			"// 0 4 \r",
			"// 1 3 \r",
			"// 2 0\r",
			"// 3 4\r",
			"// 1 5\r",
			"// 3 6"
		],
		"description": "/bfs_level"
	},
	"/dfs_2d": {
		"prefix": "/dfs_2d",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define endl '\\n'\r",
			"using namespace std;\r",
			"char a[20][20];\r",
			"bool vis[20][20];\r",
			"vector<pair<int,int>>d={{0,1},{0,-1},{-1,0},{1,0}};\r",
			"int n,m;\r",
			"bool valid(int x,int y){\r",
			"    return (x>=0 and x<n and y>=0 and y<m);\r",
			"}\r",
			"\r",
			"void dfs(int x,int y){\r",
			"    cout<<x<<\" \"<<y<<endl;\r",
			"    vis[x][y]=true;\r",
			"    for(int i=0;i<4;i++){\r",
			"        int ci=x+d[i].first;\r",
			"        int cj=y+d[i].second;\r",
			"        if(valid(ci,cj) and !vis[ci][cj]){\r",
			"            dfs(ci,cj);\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"    cin>>n>>m;\r",
			"    for(int i=0;i<n;i++){\r",
			"        for(int j=0;j<m;j++){\r",
			"            cin>>a[i][j];\r",
			"        }\r",
			"    }\r",
			"    int x,y; cin>>x>>y;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    memset(a,0,sizeof(a));\r",
			"    dfs(x,y);\r",
			"}"
		],
		"description": "/dfs_2d"
	},
	"/dfs": {
		"prefix": "/dfs",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define endl '\\n'\r",
			"using namespace std;\r",
			"const int N=1e5+10; \r",
			"vector<int>graph[N];\r",
			"bool vis[N];\r",
			"\r",
			"void dfs(int src){\r",
			"    cout<<src<<endl;\r",
			"    vis[src]=true;\r",
			"    for(auto child:graph[src]){\r",
			"        if(!vis[child]) dfs(child);\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"    int n,e; cin>>n>>e;\r",
			"    while(e--){\r",
			"        int x,y; cin>>x>>y;\r",
			"        graph[x].push_back(y);;\r",
			"        graph[y].push_back(x);;\r",
			"    }\r",
			"    int src; cin>>src;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    dfs(src);\r",
			"}"
		],
		"description": "/dfs"
	},
	"/bfs_2d": {
		"prefix": "/bfs_2d",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#define endl '\\n'\r",
			"using namespace std;\r",
			"char a[20][20];\r",
			"bool vis[20][20];\r",
			"int dis[20][20];\r",
			"vector<pair<int,int>>d={{0,1},{0,-1},{-1,0},{1,0}};\r",
			"int n,m;\r",
			"bool valid(int x,int y){\r",
			"    return (x>=0 and x<n and y>=0 and y<m);\r",
			"}\r",
			"\r",
			"void bfs(int x,int y){\r",
			"    queue<pair<int,int>>q;\r",
			"    q.push({x,y});\r",
			"    vis[x][y]=true;\r",
			"    dis[x][y]=0;\r",
			"    while(q.size()){\r",
			"        pair<int,int> par=q.front();\r",
			"        int a=par.first, b=par.second;\r",
			"        // cout<<a<<\" \"<<b<<endl;\r",
			"        q.pop();\r",
			"        for(int i=0;i<4;i++){\r",
			"            int ci=a+d[i].first;\r",
			"            int cj=b+d[i].second;\r",
			"            if(valid(ci,cj) and !vis[ci][cj]){\r",
			"                q.push({ci,cj});\r",
			"                vis[ci][cj]=true;\r",
			"                dis[ci][cj]=dis[a][b]+1;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
			"    cin>>n>>m;\r",
			"    for(int i=0;i<n;i++){\r",
			"        for(int j=0;j<m;j++){\r",
			"            cin>>a[i][j];\r",
			"        }\r",
			"    }\r",
			"    int x,y; cin>>x>>y;\r",
			"    memset(vis,false,sizeof(vis));\r",
			"    memset(dis,-1,sizeof(dis));\r",
			"    memset(a,0,sizeof(a));\r",
			"    bfs(x,y);\r",
			"    cout<<dis[0][3];\r",
			"}\r",
			"/*\r",
			"3 4 \r",
			"....\r",
			"....\r",
			"....\r",
			"0 0\r",
			"*/"
		],
		"description": "/bfs_2d"
	},
	"/heap_min": {
		"prefix": "/heap_min",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"\r",
			"int main(){\r",
			"    int n; cin>>n;\r",
			"    vector<int>v;\r",
			"    for(int i=0;i<n;i++){\r",
			"        int x; cin>>x;\r",
			"        v.push_back(x);\r",
			"        int cur=v.size()-1;\r",
			"        while(cur){\r",
			"            int par=(cur-1)/2;\r",
			"            if(v[par]>v[cur]) swap(v[cur],v[par]);\r",
			"            cur=par;\r",
			"        }        \r",
			"    }\r",
			"    for(auto x:v) cout<<x<<\" \";\r",
			"}"
		],
		"description": "/heap_min"
	},
	"/heap_delete": {
		"prefix": "/heap_delete",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"\r",
			"void insert(vector<int>&v, int x){\r",
			"    v.push_back(x);\r",
			"    int cur=v.size()-1;\r",
			"    while(cur){\r",
			"        int par=(cur-1)/2;\r",
			"        if(v[par]<v[cur]) swap(v[cur],v[par]);\r",
			"        else break;\r",
			"        cur=par;\r",
			"    }        \r",
			"}\r",
			"\r",
			"void delete_(vector<int>&v){\r",
			"    v[0]=v[v.size()-1];\r",
			"    v.pop_back();\r",
			"    int cur=0;\r",
			"    while(69){\r",
			"        int l=cur*2+1;\r",
			"        int r=cur*2+2;\r",
			"        if(l<v.size() and r<v.size()){\r",
			"            if(v[l]>=v[r] and v[l]>v[cur]){\r",
			"                swap(v[l],v[cur]);\r",
			"                cur=l;\r",
			"            }\r",
			"            else if(v[r]>=v[l] and v[r]>v[cur]){\r",
			"                swap(v[r],v[cur]);\r",
			"                cur=r;\r",
			"            }\r",
			"            else break;\r",
			"        }\r",
			"        else if(l<v.size()){\r",
			"            if(v[l]>v[cur]){\r",
			"                swap(v[l],v[cur]);\r",
			"                cur=l;\r",
			"            }\r",
			"            else break;\r",
			"        }\r",
			"        else if(r<v.size()){\r",
			"            if(v[r]>v[cur]){\r",
			"                swap(v[r],v[cur]);\r",
			"                cur=r;\r",
			"            }\r",
			"            else break;\r",
			"        }\r",
			"        else break;\r",
			"    }\r",
			"}\r",
			"\r",
			"void print(vector<int>&v){\r",
			"    for(auto x:v) cout<<x<<\" \";\r",
			"    cout<<endl;\r",
			"}\r",
			"\r",
			"int main(){\r",
			"    int n; cin>>n;\r",
			"    vector<int>v;\r",
			"    for(int i=0;i<n;i++){\r",
			"        int x; cin>>x;\r",
			"        insert(v,x);\r",
			"    }\r",
			"    print(v);\r",
			"    delete_(v);\r",
			"    print(v);\r",
			"    delete_(v);\r",
			"    print(v);\r",
			"    delete_(v);\r",
			"    print(v);\r",
			"}"
		],
		"description": "/heap_delete"
	},
	"singly": {
		"prefix": "//singly",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "class node{",
		  "    public:",
		  "        int data;",
		  "        node *next;",
		  "    node(int x){",
		  "        data=x;",
		  "        next=NULL;",
		  "    }",
		  "};",
		  "",
		  "int size(node *&head){",
		  "    int cnt=0;",
		  "    node *tmp=head;",
		  "    while(tmp){",
		  "        cnt++;",
		  "        tmp=tmp->next;",
		  "    }",
		  "    return cnt;",
		  "}",
		  "",
		  "void insert_head(node *&head, int x){",
		  "    node *newNode=new node(x);",
		  "    newNode->next=head; // notun node er next e head connect korlam ",
		  "    head=newNode; // notun node ta head banmai dilam",
		  "}",
		  "",
		  "void insert_tail(node *&head, int x){",
		  "    node *newNode=new node(x);",
		  "    node *tmp=head;",
		  "    while(tmp->next){",
		  "        tmp=tmp->next; // head theke loop chalai last e gelam",
		  "    }",
		  "    tmp->next=newNode; // last e new node connect kore dilam",
		  "}",
		  "",
		  "void insert_pos(node *&head,int pos,int x){",
		  "    if(pos<=0){",
		  "        insert_head(head,x);",
		  "        return;",
		  "    }",
		  "    if(pos>=size(head)){",
		  "        insert_tail(head,x);",
		  "        return;",
		  "    }",
		  "    node *newNode=new node(x);",
		  "    node *tmp=head;",
		  "    for(int i=1;i<pos;i++){",
		  "        tmp=tmp->next; // head theke loop chalai position e gelam",
		  "    }",
		  "    newNode->next=tmp->next; // age new tar shathe next ta connect",
		  "    tmp->next=newNode; // tarpor new ta main tai connect",
		  "}",
		  "",
		  "void delete_pos(node *&head,int pos){",
		  "    if(!(size(head))) return; // size zero hoile delete korbo na",
		  "    if(pos<0 || pos>=size(head)){ // position 0 er choto ba size er boro dile invalid position",
		  "        cout<<\"Invalid position!\"<<endl;",
		  "        return;",
		  "    }",
		  "    node* tmp=head;",
		  "    if(pos==0){ ",
		  "        head=head->next; // head er next head hobe",
		  "        delete tmp; ",
		  "        return;",
		  "    }",
		  "    for(int i=1;i<pos;i++){",
		  "        tmp=tmp->next; // loop chalai deleting node er ager position e jabo",
		  "    }",
		  "    node* deleteNode=tmp->next; // position er porerta delete korar jonno nibo ",
		  "    tmp->next=tmp->next->next; // deleting node er porer tar shathe deleting node er ager tar connection korbo",
		  "    delete deleteNode; // delete",
		  "}",
		  "",
		  "void print(node *head){",
		  "    cout<<\"List: \"<<endl;",
		  "    node *tmp=head;",
		  "    while(tmp!=NULL){",
		  "        cout<<tmp->data<<\" \";",
		  "        tmp=tmp->next;",
		  "    }",
		  "    cout<<endl;",
		  "}",
		  "",
		  "int main(){",
		  "    node* head=NULL;",
		  "    while(69){",
		  "        cout<<\"1: Insert\"<<endl;",
		  "        cout<<\"2: Delete\"<<endl;",
		  "        cout<<\"3: Print list\"<<endl;",
		  "        cout<<\"4: Exit program\"<<endl;",
		  "        int choice; cin>>choice;",
		  "        if(choice==1){",
		  "            cout<<\"Enter value: \";",
		  "            int val; cin>>val;",
		  "            cout<<\"Enter position: \";",
		  "            int pos; cin>>pos;",
		  "            insert_pos(head,pos,val);",
		  "        }",
		  "        else if(choice==2){",
		  "            cout<<\"Enter position to delete: \";",
		  "            int pos; cin>>pos;",
		  "            delete_pos(head,pos);",
		  "        }",
		  "        else if(choice==3) print(head);",
		  "        else if(choice==4) break;",
		  "        else cout<<\"Invalid choice!\"<<endl;",
		  "    }",
		  "}"
		],
		"description": ""
	},
	"doubly": {
		"prefix": "//doubly",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "class node{",
		  "public:",
		  "    int data;",
		  "    node *prev;",
		  "    node *next;",
		  "    node(int x){",
		  "        data=x;",
		  "        prev=NULL;",
		  "        next=NULL;",
		  "    }",
		  "};",
		  "",
		  "int size(node *&head){",
		  "    int cnt=0;",
		  "    node *tmp=head;",
		  "    while(tmp){",
		  "        cnt++;",
		  "        tmp=tmp->next;",
		  "    }",
		  "    return cnt;",
		  "}",
		  "",
		  "void insert_head(node *&head, int x){",
		  "    node *newNode=new node(x);",
		  "    if(!head){",
		  "        head=newNode;",
		  "        return;",
		  "    }",
		  "    newNode->next=head;",
		  "    head->prev=newNode;",
		  "    head=newNode;",
		  "}",
		  "",
		  "void insert_tail(node *&head,int x){",
		  "    node *newNode=new node(x);",
		  "    if(!head){",
		  "        head=newNode;",
		  "        return;",
		  "    }",
		  "    node *tmp=head;",
		  "    while(tmp->next){",
		  "        tmp=tmp->next;",
		  "    }",
		  "    tmp->next=newNode;",
		  "    newNode->prev=tmp;",
		  "}",
		  "",
		  "void insert_pos(node *&head,int pos,int x){",
		  "    if(pos<=0){",
		  "        insert_head(head,x);",
		  "        return;",
		  "    }",
		  "    if(pos>=size(head)){",
		  "        insert_tail(head,x);",
		  "        return;",
		  "    }",
		  "    node *newNode=new node(x);",
		  "    node *tmp=head;",
		  "    for(int i=1;i<pos;i++){",
		  "        tmp=tmp->next;",
		  "    }",
		  "    newNode->next=tmp->next;",
		  "    newNode->prev=tmp;",
		  "    tmp->next->prev=newNode;",
		  "    tmp->next=newNode;",
		  "}",
		  "",
		  "void delete_pos(node *&head,int pos){",
		  "    if(!size(head)){",
		  "        cout<<\"List is empty!\"<<endl;",
		  "        return;",
		  "    }",
		  "    if(pos<0 || pos>=size(head)){",
		  "        cout<<\"Invalid position!\"<<endl;",
		  "        return;",
		  "    }",
		  "    node* tmp=head;",
		  "    if(pos==0){",
		  "        head=head->next;",
		  "        delete tmp;",
		  "        if(head) head->prev=NULL;",
		  "        return;",
		  "    }",
		  "    for(int i=0;i<pos;i++){",
		  "        tmp=tmp->next;",
		  "    }",
		  "    tmp->prev->next=tmp->next;",
		  "    if(tmp->next) tmp->next->prev=tmp->prev;",
		  "    delete tmp;",
		  "}",
		  "",
		  "void print(node *head){",
		  "    cout<<\"List: \";",
		  "    node *tmp=head;",
		  "    while(tmp){",
		  "        cout<<tmp->data<<\" \";",
		  "        tmp=tmp->next;",
		  "    }",
		  "    cout<<endl;",
		  "}",
		  "",
		  "int main() {",
		  "    node* head=NULL;",
		  "    while(69){",
		  "        cout<<\"1: Insert\"<<endl;",
		  "        cout<<\"2: Delete\"<<endl;",
		  "        cout<<\"3: Print list\"<<endl;",
		  "        cout<<\"4: Exit program\"<<endl;",
		  "        int choice; cin>>choice;",
		  "        if(choice==1){",
		  "            cout<<\"Enter value: \";",
		  "            int val; cin>>val;",
		  "            cout<<\"Enter position: \";",
		  "            int pos; cin>>pos;",
		  "            insert_pos(head,pos,val);",
		  "        }",
		  "        else if(choice==2){",
		  "            cout<<\"Enter position to delete: \";",
		  "            int pos; cin>>pos;",
		  "            delete_pos(head,pos);",
		  "        }",
		  "        else if(choice==3) print(head);",
		  "        else if(choice==4) break;",
		  "        else cout<<\"Invalid choice!\"<<endl;",
		  "    }",
		  "}",
		  ""
		],
		"description": ""
	  },
	  "circular": {
		"prefix": "//circular",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "class node{",
		  "    public:",
		  "        int data;",
		  "        node *next;",
		  "    node(int x){",
		  "        data=x;",
		  "        next=NULL;",
		  "    }",
		  "};",
		  "",
		  "int size(node *head){",
		  "    if(!head) return 0;",
		  "    int cnt=0;",
		  "    node *tmp=head->next;",
		  "    cnt++; //age ekta count korte hobe",
		  "    while(tmp!=head){",
		  "        tmp=tmp->next;",
		  "        cnt++;",
		  "    }",
		  "    return cnt;",
		  "}",
		  "",
		  "void insert_head(node *&head,int x){",
		  "    node *newNode=new node(x);",
		  "    if(!head){",
		  "        newNode->next=newNode;",
		  "        head=newNode;",
		  "        return;",
		  "    }",
		  "    newNode->next=head->next; ",
		  "    head->next=newNode;",
		  "    int temp=head->data;",
		  "    head->data=newNode->data;",
		  "    newNode->data=temp;",
		  "}",
		  "",
		  "void insert_tail(node *&head,int x){",
		  "    insert_head(head,x);",
		  "    head=head->next;",
		  "}",
		  "",
		  "void insert_pos(node *&head,int pos,int x){",
		  "    if(pos<=0){",
		  "        insert_head(head,x);",
		  "        return;",
		  "    }",
		  "    if(pos>=size(head)){",
		  "        insert_tail(head,x);",
		  "        return;",
		  "    }",
		  "    node *newNode=new node(x);",
		  "    node *tmp=head;",
		  "    for(int i=1;i<pos;i++){",
		  "        tmp=tmp->next;",
		  "    }",
		  "    newNode->next=tmp->next;",
		  "    tmp->next=newNode;",
		  "}",
		  "",
		  "void delete_pos(node *&head,int pos){",
		  "    if(!head) return;",
		  "    if(pos<0 || pos>=size(head)){",
		  "        cout<<\"Invalid position!\"<<endl;",
		  "        return;",
		  "    }",
		  "    node* tmp=head;",
		  "    if(pos==0){",
		  "        head=head->next;",
		  "        delete tmp;",
		  "        return;",
		  "    }",
		  "    for(int i=1;i<pos;i++){",
		  "        tmp=tmp->next;",
		  "    }",
		  "    node* deleteNode=tmp->next;",
		  "    tmp->next=tmp->next->next;",
		  "    delete deleteNode;",
		  "}",
		  "",
		  "void print(node *head){",
		  "    if(!head){",
		  "        cout<<\"List is emplty!\"<<endl;",
		  "        return;",
		  "    }",
		  "    cout<<\"List: \";",
		  "    node *tmp=head->next;",
		  "    cout<<head->data<<\" \";",
		  "    while(tmp!=head){",
		  "        cout<<tmp->data<<\" \";",
		  "        tmp=tmp->next;",
		  "    }",
		  "    cout<<endl;",
		  "}",
		  "",
		  "int main(){",
		  "    node* head=NULL;",
		  "    while(69){",
		  "        cout<<\"1: Insert\"<<endl;",
		  "        cout<<\"2: Delete\"<<endl;",
		  "        cout<<\"3: Print list\"<<endl;",
		  "        cout<<\"4: Exit program\"<<endl;",
		  "        int choice; cin>>choice;",
		  "        if(choice==1){",
		  "            cout<<\"Enter value: \";",
		  "            int val; cin>>val;",
		  "            cout<<\"Enter insert position: \";",
		  "            int pos; cin>>pos;",
		  "            insert_pos(head,pos,val);",
		  "        }",
		  "        else if(choice==2){",
		  "            cout<<\"Enter delete position: \";",
		  "            int pos; cin>>pos;",
		  "            delete_pos(head,pos);",
		  "        }",
		  "        else if(choice==3) print(head);",
		  "        else if(choice==4) break;",
		  "        else cout<<\"Invalid choice!\"<<endl;",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "stack": {
		"prefix": "//stack",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "const int N=100;",
		  "",
		  "class Stack{",
		  "public:",
		  "    int a[N];",
		  "    int t;",
		  "    Stack(){t=-1;}",
		  "    bool empty(){return t==-1;} // eikhane == use korsi",
		  "    bool full(){return t==N-1;} // eikhaneo",
		  "    void push(int x){",
		  "        if(full()){",
		  "            cout<<\"Stack overflow!\"<<endl;",
		  "            return;",
		  "        }",
		  "        t++;",
		  "        a[t]=x; ",
		  "    }",
		  "    void pop(){",
		  "        if(empty()){",
		  "            cout<<\"Stack underflow!\"<<endl;",
		  "            return;",
		  "        }",
		  "        t--;",
		  "    }",
		  "    int top(){",
		  "        if(empty()){",
		  "            cout<<\"Stack is empty!\"<<endl;",
		  "            return -1;",
		  "        }",
		  "        return a[t];",
		  "    }",
		  "};",
		  "",
		  "int main() {",
		  "    Stack s;",
		  "    int n; cin>>n;",
		  "    while(n--){",
		  "        int x; cin>>x;",
		  "        s.push(x);",
		  "    }",
		  "    while(!s.empty()){",
		  "        cout<<s.top()<<\" \";",
		  "        s.pop();",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  " 5": {
		"prefix": "//queue",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "const int N=3;",
		  "",
		  "class Queue{",
		  "public:",
		  "    int a[N];",
		  "    int f,r;",
		  "    Queue(){",
		  "        f=-1;",
		  "        r=-1;",
		  "    }",
		  "    bool empty(){",
		  "        return f==-1 && r==-1;",
		  "    }",
		  "    bool full(){",
		  "        if(r+1==N) r==0;",
		  "        return (r+1)%N==f;",
		  "    }",
		  "    void push(int x){",
		  "        if(full()){",
		  "            cout<<\"Queue is full!\"<<endl;",
		  "            return;",
		  "        }",
		  "        else if(empty()) f=r=0;",
		  "        else if(r+1==N) r=0;",
		  "        else r++;",
		  "        a[r]=x;",
		  "    }",
		  "    void pop(){",
		  "        if(empty()){",
		  "            cout<<\"Queue is empty!\"<<endl;",
		  "            return;",
		  "        }",
		  "        else if(f==r) f=r=-1;",
		  "        else if(f+1==N) f=0;",
		  "        else f++;",
		  "    }",
		  "    int front(){",
		  "        if(empty()){",
		  "            cout<<\"Queue is empty!\"<<endl;",
		  "            return-1;",
		  "        }",
		  "        return a[f];",
		  "    }",
		  "};",
		  "",
		  "int main(){",
		  "    Queue q;",
		  "    int n; cin>>n;",
		  "    while(n--){",
		  "        int x; cin>>x;",
		  "        q.push(x);",
		  "    }",
		  "    while(!q.empty()){",
		  "        cout<<q.front()<<\" \";",
		  "        q.pop();",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  " 55": {
		"prefix": "//tree",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "class Node{",
		  "    public:",
		  "        int val;",
		  "        Node *right;",
		  "        Node *left;",
		  "    Node(int x){",
		  "        val=x;",
		  "        right=NULL;",
		  "        left=NULL;",
		  "    }",
		  "};",
		  "",
		  "void preorder(Node* root){",
		  "    if(root==NULL) return;",
		  "    cout<<root->val<<\" \";",
		  "    preorder(root->left);",
		  "    preorder(root->right);",
		  "}",
		  "",
		  "void inorder(Node* root){",
		  "    if(root==NULL) return;",
		  "    inorder(root->left);",
		  "    cout<<root->val<<\" \";",
		  "    inorder(root->right);",
		  "}",
		  "",
		  "void postorder(Node* root){",
		  "    if(root==NULL) return;",
		  "    postorder(root->left);",
		  "    postorder(root->right);",
		  "    cout<<root->val<<\" \";",
		  "}",
		  "",
		  "int main(){",
		  "    Node* root=new Node(10);",
		  "    Node* a=new Node(20);",
		  "    Node* b=new Node(30);",
		  "    Node* c=new Node(40);",
		  "    Node* d=new Node(50);",
		  "    Node* e=new Node(60);",
		  "    Node* f=new Node(70);",
		  "    Node* g=new Node(80);",
		  "    Node* h=new Node(90);",
		  "    Node* i=new Node(100);",
		  "    // Conection ",
		  "    root->left=a;",
		  "    root->right=b;",
		  "    a->left=c;",
		  "    a->right=h;",
		  "    c->right=e;",
		  "    b->right=d;",
		  "    d->left=f;",
		  "    d->right=g;",
		  "    h->left=i;",
		  "    preorder(root);",
		  "    cout<<endl;",
		  "    inorder(root);",
		  "    cout<<endl;",
		  "    postorder(root);",
		  "    cout<<endl;",
		  "}",
		  "    //        10",
		  "    //       /  \\",
		  "    //     20    30",
		  "    //    /  \\    \\",
		  "    //   40  90    50",
		  "    //       /    /  \\",
		  "    //     100   70  80"
		],
		"description": ""
	  },
	  " 1": {
		"prefix": "/insertion",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "int main(){",
		  "    int n; cin>>n;",
		  "    int a[n];",
		  "    for(int i=0;i<n;i++){",
		  "        cin>>a[i];",
		  "    }",
		  "    for(int i=1;i<n;i++){",
		  "        int key=a[i];",
		  "        int j=i-1;",
		  "        while(j>=0 && a[j]>key){",
		  "            a[j+1]=a[j];",
		  "            j--;",
		  "        }",
		  "        a[j+1]=key;",
		  "    }",
		  "    for(int i=0;i<n;i++){",
		  "        cout<<a[i]<<\" \";",
		  "    }",
		  "}"
		],
		"description": ""
	  },
	  "2 ": {
		"prefix": "//binary",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "int main() {",
		  "    cout<<\"Input sorted array: \";",
		  "    int n; cin>>n;",
		  "    int a[n];",
		  "    for(int i=0;i<n;i++) cin>>a[i];",
		  "    cout << \"Input element to find: \";",
		  "    int find;",
		  "    cin>>find;",
		  "    int l=0;",
		  "    int r=n-1;",
		  "    while(r>=l){",
		  "        int m=(l+r)/2;",
		  "        if(a[m]==find){",
		  "            cout<<\"Found\\n\";",
		  "            return 0;",
		  "        }",
		  "        else if(a[m]>find) r=m-1;",
		  "        else l=m+1;",
		  "    }",
		  "    cout<<\"Not Found\\n\";",
		  "}"
		],
		"description": ""
	  },
	  " 3": {
		"prefix": "//graph",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "const int N=1e5+10; ",
		  "vector<int>graph[N];",
		  "bool vis_bfs[N];",
		  "bool vis_dfs[N];",
		  "",
		  "void dfs(int src){",
		  "    cout<<src<<\" \";",
		  "    vis_dfs[src]=true;",
		  "    for(auto child:graph[src]){",
		  "        if(!vis_dfs[child]) dfs(child);",
		  "    }",
		  "}",
		  "",
		  "void bfs(int src){",
		  "    queue<int>q;",
		  "    q.push(src);",
		  "    vis_bfs[src]=true;",
		  "    while(q.size()){",
		  "        int par=q.front();",
		  "        q.pop(); ",
		  "        cout<<par<<\" \";",
		  "        for(auto child:graph[par]){",
		  "            if(!vis_bfs[child]){",
		  "                q.push(child);",
		  "                vis_bfs[child]=true;",
		  "            }",
		  "        }",
		  "    }",
		  "}",
		  "",
		  "int main(){",
		  "    int n,e; cin>>n>>e;",
		  "    while(e--){",
		  "        int x,y; cin>>x>>y;",
		  "        graph[x].push_back(y);",
		  "        graph[y].push_back(x);",
		  "    }",
		  "    // int src; cin>>src;",
		  "    memset(vis_bfs,false,sizeof(vis_bfs));",
		  "    memset(vis_dfs,false,sizeof(vis_dfs));",
		  "    cout<<\"BFS Traversal: \";",
		  "    bfs(0);",
		  "    cout<<endl;",
		  "    cout<<\"DFS Traversal: \";",
		  "    dfs(0);",
		  "}",
		  "// 7 8",
		  "// 0 1 ",
		  "// 1 2 ",
		  "// 0 4 ",
		  "// 1 3 ",
		  "// 2 0",
		  "// 3 4",
		  "// 1 5",
		  "// 3 6"
		],
		"description": ""
	  },
	  "6 ": {
		"prefix": "//bst",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "const int N = 1e5 + 10;",
		  "int Tree[N];",
		  "",
		  "void insert(int idx,int x){",
		  "    if(Tree[idx]==-1){",
		  "        Tree[idx]=x;",
		  "        return;",
		  "    }",
		  "    if(x<Tree[idx]) insert(idx*2+1,x);",
		  "    else if(x>Tree[idx]) insert(idx*2+2,x);",
		  "}",
		  "",
		  "void inorder(int idx){",
		  "    if(Tree[idx]!=-1){",
		  "        inorder(idx*2+1);",
		  "        cout<<Tree[idx]<<\" \";",
		  "        inorder(idx*2+2);",
		  "    }",
		  "}",
		  "",
		  "int main(){",
		  "    int head=0;",
		  "    memset(Tree,-1,sizeof(Tree));",
		  "    cout<<\"Enter number of node: \"<<endl;",
		  "    int n; cin>>n;",
		  "    for(int i=0;i<n;i++){",
		  "        int x; cin>>x;",
		  "        insert(head,x);",
		  "    }",
		  "    cout<<\"Inorder Traversal: \";",
		  "    inorder(head);",
		  "}"
		],
		"description": ""
	  },
	  " ": {
		"prefix": "//postfix",
		"body": [
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "float operation(float a,float b,char op){",
		  "   if(op=='+') return b+a;",
		  "   else if(op=='-') return b-a;",
		  "   else if(op=='*') return b*a;",
		  "   else if(op=='/') return b/a;",
		  "   else if(op=='^') return pow(b,a);",
		  "}",
		  "",
		  "float postfixEval(string postfix){",
		  "    int a,b;",
		  "    stack<float>st;",
		  "    for(auto ch:postfix){",
		  "        if(ch=='+' || ch=='-' || ch=='*' || ch=='/' || ch=='^'){",
		  "            a=st.top();",
		  "            st.pop();",
		  "            b=st.top();",
		  "            st.pop();",
		  "            st.push(operation(a,b,ch));",
		  "        }",
		  "        else st.push(ch-'0');",
		  "    }",
		  "    return st.top();",
		  "}",
		  "",
		  "main(){",
		  "   string post=\"653-/215+*+\";",
		  "   cout<<\"The result is: \"<<postfixEval(post);",
		  "}"
		],
		"description": ""
	  }
}
